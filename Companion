#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Companion
# 2024 Copyright © Robert APM Darin
# All rights reserved unconditionally.

# ***** IMPORTANT:
#   This program uses ADMINISTRATOR priviledges.

# Forum and thread support is a strange approach. Threads are treated like
# channels, with a few extra bits. Webhooks, slowdown mode, edits, even the way
# message are sent into the thread is effected. Activitieshave to be tested and
# is it is a thread, most of the time, you have to pull the parent channel.
# Webhooks and slowdown mode, in particular, do NOT have separate
# functionalities of a channel, even though discord treats them like a channel.

### *** At some point, I'm going to really have to rewrite this. The forum/thread
###     detection code is a stinking hot mess and scattered everywhere.

# Areas where a classifier can improve functionality (at a higher cost):
#   Phone number detection would have a significantly lower lecel of false positives.
#   Technical messages versus non-technical for varying the temperature of the
#       conversation.

# Listed in order of when the service was added.

# added openai
# added ollama
# added together.ai     Free models available.
# added cohere          Trial key 1000 free requests per month
# added huggingface     free key is 1000 requests per day, fragmented responses, 1
#                       respons coud = 8 requests or more
# added anthropic       token counting is a hot mess, but functional,
#                       no free credits, pay upfront
# added perplexity.ai   No free credits, pay upfront, search oriented, not
#                       good for conversational, but searching is outstanding.
# added openrouter.ai   Several free models, has just about every major
#                       provider, even some of the more difficult ones
#                       to build for. Paid models will have a premium
#                       for the normalization service. No direct model
#                       support like you would get directly from model
#                       vender (OpenAI, Anthropic, so on). Uses all
#                       OpenAI code. Token counting is a nighmare but
#                       the basic len/4 works reasonly well. toktoken()
#                       does NOT work.

# --> Not in a specific order, add support for the following engines (Maybe):

#   GitHub model
#   DeepInfra           https://deepinfra.com/pricing
#   fireworks.ai
#   Azure
#   Anyscale
#   Replicate
#   google.ai (genini)  This is a hot mess to try to develop for. There
#                       are a serious cascading issues from message
#                       format to usage consideration... The API is
#                       free, but the developement process is hideous.
#   Vertex AI           Now GoogleAI
#   AI21labs            Seriously broken in multiple ways. API does not work.
#                       Disappointing becuse this really looked put
#                       together with as much expertise as Open AI, even
#                       directly addressing token counting upfront.
#   OctoML AI           Bought out by NVIDIA. (Web site broken with 500
#                       internal server error.

# Special USER commands: (Completed)

#   %http           Read URLs, YouTube transcripts, and PDFs
#   %yttags         Get YouTube video tage, if there are any.
#   %Forget         Tell the AI to forget the conversation in the current channel
#   %AnagramSolver  Solve Anagrams

# Developer/Admin only: (Completed)

#   %PurgeRequests  Empty the server request queue
#   %CheckBot       Check if the AI is allowed in a channel

# Needed functionality

#   Purge memory that are older then X days automatically - completed
#   Imposter detection - completed
#   Auto slow mode - completed
#   Anti-raid - completed
#   Find a way to identify personal information: email, phone numbers, SSN, EIN,
#       Credit Card numbers - completed

#   Anti nuke
#   Ticket management
#   Anti nudity verification for images.
#   URL check (abuseIPDB) verifications.

# Disable 3rd party logging.
import warnings
warnings.filterwarnings('ignore')
import logging
logging.basicConfig(level=logging.CRITICAL)
logger=logging.getLogger('transformers')
logger.setLevel(logging.CRITICAL)
logger.handlers=[]

import sys
import os
import io
import copy
import itertools
import datetime
import time
import json
import random
import string
import concurrent.futures
import threading
import urllib.request
import requests
import re
import asyncio
import discord
from discord.ext import commands, tasks
import profanity_check as pc
import pdfplumber
import tiktoken
import openai
import ollama
import together
import cohere
from huggingface_hub import InferenceClient
import anthropic
import youtube_transcript_api
import imagehash
from transformers import AutoTokenizer
from googleapiclient.discovery import build
from PIL import Image
from io import BytesIO

# Active version

Version="0.0.0.0.1020"

# The running name of the program. Must be global and NEVER changing.

RunningName=sys.argv[0]

# Persona base folder. This is where all personas are stored.

CompanionBase='/home/Companion'
CompanionStorage=f'{CompanionBase}/Personas'
MemoryStorage=f'{CompanionBase}/Servers/Memory'
LoggingStorage=f'{CompanionBase}/Servers/Logs'
ConfigStorage=f'{CompanionBase}/Servers/Config'

# For anagram solver
AnagramWordList=f'{CompanionBase}/AnagramSolver.txt'

# This is a list of domains that are scams, frauds, or malitiouc. It is exists, it is read and message that
# have links listed are removed. Requires the persona text file as well for responses.

CompanionScamURLS=f'{CompanionBase}/Companion.scam-urls'
CompanionAutoFilter=f'{CompanionBase}/Companion.autofilter'

# `GuildQueueLock`: Ensures safe modification of the guild queue structure during
# request management across different servers.

GuildQueue=[]
GuildQueueLock=threading.Lock()
GuildQueueTimeout=60

# `ResponseLock`: Prevents simultaneous modifications when queuing responses for
# processing.

ResponseLock=threading.Lock()
ResponseTimeout=60

# `DeleteLock`: Manages safe scheduling of message deletions without conflicts.

DeleteLock=threading.Lock()
DeleteTimeout=60

# `DisectLock`: Ensures accurate logging by preventing overlapping writes during message
# dissection.

DisectLock=threading.Lock()
DisectTimeout=60

# `BabbleLock`: Provides concurrency control per server while allowing parallelism
# across different servers.

LoggingLock=threading.Lock()
LoggingTimeout=60

# Each server must have it own lock to insure concurrency under heavy
# load. Requests per server are still sequential. This should prevent
# active servers from hogging resources from smaller or less active
# servers.

BabbleLock={}
BabbleTimeout=60

# Constants For auto slowmode. Needs to be dymanic in the future
SLOW_MODE_DURATION = 3  # Seconds for individual slow mode
SLOW_MODE_COOLDOWN = 307  # 5 minutes/7 secords cooldown for slow mode adjustments

# Dictionary to store the last slow mode change time for each channel
last_slow_mode_change = {}

# For counting active users per chanel
active_users={}

# For active member joins. anti raid messures. Will be a multiplier for slowdown
# mode if above 1% of total users.
active_joins={}

# This is required for the bot to work properly.

intents=discord.Intents.all()
intents.presences=True
intents.guilds=True
intents.messages=True
intents.message_content=True
intents.members=True

# Create a Discord client
client=discord.Client(intents=intents)

### Really need to make these files on disk and not global memory lists, for
### sharding/multi process management.

# List to stowre timed messages for deletion
delete_list=[]

###
### General file tools
###

# Cheap mkdir

def mkdir(fn):
    if not os.path.exists(fn):
        os.makedirs(fn,exist_ok=True)

# Helper function to download and load an image from a URL

def LoadImageURL(url):
    response=requests.get(url)
    img=Image.open(BytesIO(response.content))
    return img

# Read file into buffer

def ReadFile(fn,binary=False):
    if os.path.exists(fn):
        if binary:
            cf=open(fn,'rb')
            buffer=cf.read()
            cf.close()
        else:
            cf=open(fn,'r')
            buffer=cf.read().strip()
            cf.close()
    else:
        buffer=None
    return buffer

# Append a single line to an existing file

def AppendFile(fname,text):
    fh=open(fname,'a+')
    fh.write(text)
    fh.close()

# Write file to disk

def WriteFile(fn,data):
    cf=open(fn,'w')
    cf.write(data)
    cf.close()

# Pick one line from a file as a response

def ReadFile2List(fname,ForceLower=False):
    # Something broke. Keep the responses in character
    responses=ReadFile(fname).strip().split('\n')
    while '' in responses:
        responses.remove('')
    if ForceLower==True:
        responses=[item.lower() for item in responses]
    return responses

# Pick a random response from a filew
# Something broke. Keep the responses in character

def PickRandomResponse(fname):
    responses=ReadFile2List(fname)
    selected_response=random.choice(responses)
    if selected_response.startswith('{[(*') and selected_response.endswith('*)]}'):
        buffer=ReadFile(selected_response[4:-4].strip()).strip()
        return buffer
    return selected_response

###
### Random support functions
###

# Check a string for numbers only.

def NumberOnly(s):
    # Replace common look-alikes with their numeric equivalents
    look_alike_replacements={
        'I': '1',  # Uppercase 'i' as '1'
        'l': '1',  # Lowercase 'L' as '1'
        'O': '0',  # Uppercase 'O' as '0'
    }

    # Replace look-alikes in the input string
    for look_alike, digit in look_alike_replacements.items():
        s=s.replace(look_alike, digit)

    s=s.strip().replace(' ','')

    # Define valid characters, including look-alikes and numeric equivalents
    valid_chars=set("0123456789.,")  # Regular digits, comma, and period
    look_alike_chars=set("٠١٢٣٤٥٦٧٨٩")  # Arabic-Indic digits
    full_width_digits=set("０１２３４５６７８９")  # Full-width digits

    # Combine all valid characters into one set
    valid_chars.update(look_alike_chars)
    valid_chars.update(full_width_digits)

    # Check each character in the string
    for char in s:
        if char not in valid_chars:
            return False

    # Basic number validation: ensure the string isn't just commas or periods
    if s.replace(",", "").replace(".", "").isdigit():
        return True

    return False

# Leet list deritives for trying to get someone's age.

lside=['ask','how','is','are','your','you','when','whens','what','whats','wut','wuts','was','tell','ur','u','r']
rside=['over','old','young','under','teen','tween','tweenie','born','date','year','yr','age','birth','birthed','birthdate','birthday','bday','bd','born']

# Building the leet derivitives. This was a royal pain in the ass, but
# by doing so, if any user trying to bypass the edit detection can be
# persumed to have malicious intent.

# The BuildDerivatives function generates variations of a given word
# using common leetspeak substitutions. This is designed to catch
# altered forms of keywords that could be used to evade detection,
# ensuring that questions about sensitive topics (like age) are
# identified, even if disguised by replacing characters with
# similar-looking ones (e.g., "age" -> "4g3").

def BuildDerivitives(word):
    substitutions={
        'a': ['@','4'],
        'e': ['3'],
        'o': ['0'],
        'l': ['1', '|', '!', 'i'],
        'i': ['1', 'l', '|', '!', 'l'],
        's': ['z', '$', '5'],
        't': ['7', '+']
    }

    # Start the list
    dList=[ word ]

    # Forward in loop
    for x in range(len(word)):
        xword=list(word)
        if xword[x] in substitutions.keys():
            cList=substitutions[xword[x]]
            for y in range(len(cList)):
                xword[x]=cList[y]
                nword=''.join(xword)
                if nword not in dList:
                    dList.append(nword)

    # Forward reset at beginning
    xword=list(word)
    for x in range(len(word)):
        if xword[x] in substitutions.keys():
            cList=substitutions[xword[x]]
            for y in range(len(cList)):
                xword[x]=cList[y]
                nword=''.join(xword)
                if nword not in dList:
                    dList.append(nword)

    # Backwards
    xword=list(word)
    for x in range(len(word)-1,-1,-1):
        if xword[x] in substitutions.keys():
            cList=substitutions[xword[x]]
            for y in range(len(cList)):
                xword[x]=cList[y]
                nword=''.join(xword)
                if nword not in dList:
                    dList.append(nword)

    # return the list of words back to user
    return dList

# The BuildLeetList function creates a comprehensive list of leetspeak
# variations for a set of keywords. By applying the BuildDerivatives
# function to each word in the provided list, it generates leet-based
# variations that help detect keywords even when altered by character
# substitutions. This enables more reliable identification of disguised
# or intentionally modified words related to sensitive topics,
# supporting moderation efforts.

def BuildLeetList(side):
    leetlist=[]

    for i in range(len(side)):
        leet=BuildDerivitives(side[i])
        for j in range(len(leet)):
            if leet[j] not in leetlist:
                leetlist.append(leet[j])

    return leetlist

# Strip pucnctuation.

def StripPunctuation(text):
    # Define punctuation and high ASCII characters
    punctuation=string.punctuation
    high_ascii_chars=''.join(chr(i) for i in range(128, 256))

    # Create a translation table to map all punctuation and high ASCII characters to spaces
    translation_table=str.maketrans({**dict.fromkeys(punctuation, ' '), **dict.fromkeys(high_ascii_chars, ' ')})

    # Replace punctuation and high ASCII characters with spaces in the text
    cleaned_text=text.translate(translation_table)

    return cleaned_text

# Json filter
# Filter end of line and hard spaces

def jsonFilter(s,FilterSpace=True):
    d=s.replace("\\n","").replace("\\t","").replace("\\r","")

    if FilterSpace==True:
        filterText='\t\r\n \u00A0'
    else:
        filterText='\t\r\n\u00A0'

    for c in filterText:
        d=d.replace(c,'')

    return(d)

# Break input into a word list for steering.

def GetWordList(text):
    words=text.lower().split()                          # Split the string by spaces
    return [word for word in words if word.strip()]     # Filter out empty strings (including spaces)

# This function scans a piece of text to identify sensitive personal information, such
# as Social Security numbers, phone numbers, email addresses, credit card numbers, IP
# addresses, and Employer Identification Numbers (EINs). By checking for specific
# patterns associated with each type of information, it aims to detect and label any
# sensitive data it finds, like an email or a phone number, within the text. If it
# identifies something sensitive, it returns the type of information and the exact
# pattern found; otherwise, it confirms that no personal information was detected. This
# process helps ensure privacy by flagging potentially sensitive data in a
# straightforward way.

async def DetectPII(text):
    async def detect_phone_number(text):
        # Define phone number patterns for different countries
        phone_patterns = [
            (r'(?<!\d)(\+?86)?1[3-9]\d{9}(?!\d)', 'China'),        # China (11 digits, starts with 13-19)
            (r'(?<!\d)(\+91)?[6789]\d{9}(?!\d)', 'India'),         # India (10 digits, starts with 6-9)
            (r'(?<!\d)(\+1)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}(?!\d)', 'USA/Canada'),  # USA/Canada (10 digits, area code optional)
            (r'(?<!\d)(\+1)?\d{10}(?!\d)', 'USA/Canada'),          # USA/Canada (10 digits, no spaces or symbols)
            (r'(?<!\d)(\+55)?\(?[1-9]\d\)?[\s.-]?\d{4,5}[\s.-]?\d{4}(?!\d)', 'Brazil'),  # Brazil (10-11 digits, area code 2-9)
            (r'(?<!\d)(\+62)?8\d{8,10}(?!\d)', 'Indonesia'),       # Indonesia (9-11 digits, starts with 8)
            (r'(?<!\d)(\+7)?9\d{9}(?!\d)', 'Russia'),              # Russia (10 digits, starts with 9 after +7)
            (r'(?<!\d)(\+81)?0\d{1,4}[\s.-]?\d{1,4}[\s.-]?\d{4}(?!\d)', 'Japan'),  # Japan (varied lengths, typically 10 digits)
            (r'(?<!\d)(\+52)?\(?\d{2,3}\)?[\s.-]?\d{4,5}[\s.-]?\d{4}(?!\d)', 'Mexico'),  # Mexico (10-11 digits, area code 2-3 digits)
            (r'(?<!\d)(\+49)?\(?\d{3,4}\)?[\s.-]?\d{3,4}[\s.-]?\d{4}(?!\d)', 'Germany'),  # Germany (10-12 digits, various area codes)
            (r'(?<!\d)(\+44)?7\d{9}(?!\d)', 'UK')                 # UK (10 digits, starts with 7 after +44)
        ]

        # Step 1: Remove URLs from the text. This approach is needed because
        # URLs can be wrapped in markdown. Not perfect be far, but it does seem
        # to remove most false positives without the need of an AI classifier.

        inwords=text.lower().split()
        outwords=[]
        for word in inwords:
            if 'http://' not in word and 'https://' not in word:
                outwords.append(word)
        text=' '.join(outwords)

        # Step 2: Detect any phone numbers in the text
        for pattern, country in phone_patterns:
            match = re.search(pattern, text)
            if match:
                phone_number = match.group()

                # Skip numbers that are too short to be valid phone numbers
                if len(phone_number) > 4:
                    return (phone_number, country)
            await asyncio.sleep(0)

        # Return None if no valid phone numbers are found
        return None

    # Embedded function to validate credit card numbers using Luhn's algorithm
    def ValidCC(card_number):
        # Remove any non-digit characters for validation purposes
        card_number = ''.join(filter(str.isdigit, card_number))

        # Check for valid credit card lengths
        if len(card_number) not in [15, 16]:
            return False

        # Basic BIN check for common credit cards
        valid_bins = ('4', '5', '34', '37', '6')  # Visa, MasterCard, AmEx, Discover
        if not card_number.startswith(valid_bins):
            return False

        # Luhn algorithm to verify credit card number
        checksum = 0
        reverse_digits = card_number[::-1]
        for idx, digit in enumerate(reverse_digits):
            num = int(digit)
            # Double every second digit from the right
            if idx % 2 == 1:
                num *= 2
                if num > 9:  # If doubling results in two digits, sum them
                    num -= 9
            checksum += num
        return checksum % 10 == 0

    # Regex patterns for various types of PII
    patterns = {
        "SSN": r"\b\d{3}-\d{2}-\d{4}\b",
        "Email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
        "Credit Card": r"\b(?:\d[ -]*?){13,16}\b",
        "IPv4 Address": r"\b(?:\d{1,3}\.){3}\d{1,3}\b",
        "IPv6 Address": r"\b([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b",
        "EIN": r"\b\d{2}-\d{7}\b"
    }

    # Pattern to identify Discord mentions (e.g. <@396394433328971776>)
    discord_mention_pattern = r"<@\d{17,18}>"

    # Remove Discord mentions from sssthe text
    text_without_mentions = re.sub(discord_mention_pattern, "", text)

    # Check each PII pattern in the cleaned text
    for pii_type, pattern in patterns.items():
        match = re.search(pattern, text_without_mentions)
        if match:
            detected_value = match.group()

            # Special handling for Credit Card numbers. Ignore if not a valid
            # credit card based on the Luhn check and BIN

            if pii_type == "Credit Card" and not ValidCC(detected_value):
                continue

            return f"{pii_type}: {detected_value}"
        await asyncio.sleep(0)

        match=await detect_phone_number(text)
        if match:
            return f"Phone Number: {match}"

    # If no PII pattern was found
    return None

###
### Direct Companion functions
###

# Read the token file into a token dictionary.

def ReadTokens(gid=None):
    tokens={}
    if gid==None:
        tfile=RunningName+'.tokens'
    else:
        tfile=f"{ConfigStorage}/{gid}/{gid}.tokens"
    if os.path.exists(tfile):
        try:
            tokens=json.loads(jsonFilter(ReadFile(tfile)))
        except Exception as err:
            ErrorLog("Error token file is not in JSON format. Please see README.md for new layout")
            sys.exit(1)
    else:
        ErrorLog(f"Missing token file: {tfile}")
        sys.exit(1)

    if gid==None and 'Discord' not in tokens:
        ErrorLog("The MUST be a Discord API reference in the tokens file")
        sys.exit(1)

    return tokens

# Raw dump. For diagnostics purposes to see the actual return response from the AI model.

def RawLog(text):
    if LoggingLock.acquire(timeout=LoggingTimeout):
        try:
            mkdir(LoggingStorage)
            fn=f'{LoggingStorage}/RAWDUMP.log'
            fh=open(fn,'w')
            fh.write(text)
            fh.close()
        except:
            pass
        LoggingLock.release()

# Logging

def WriteLog(gid,uid,channel,text):
    if LoggingLock.acquire(timeout=LoggingTimeout):
        try:
            txt=text.replace('\n','\\n').replace('\r','\\r')

            time=(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))

            s=f'{time} {uid} {channel} {txt}\n'

            dn=f'{LoggingStorage}/{gid}'
            mkdir(dn)
            fn=f'{dn}/{channel}.log'
            AppendFile(fn,s)
        except Exception as err:
            print(f'LOG Broke: {err}')
            pass
        LoggingLock.release()

# Log errors

def ErrorLog(text):
    if LoggingLock.acquire(timeout=LoggingTimeout):
        try:
            txt=text.replace('\n','\\n').replace('\r','\\r')

            time=(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'))

            s=f'{time} {txt}\n'

            mkdir(LoggingStorage)
            fn=LoggingStorage+'/Errors.log'
            AppendFile(fn,s)

            # print to console
            print(txt)
        except:
            pass
        LoggingLock.release()

# The `MaintainTokenLimit` function is responsible for ensuring that the messages sent
# to the AI do not exceed a specific limit on the number of tokens used. Tokens are
# units of text that the AI processes, and each message can contain a varying number of
# tokens based on its length and complexity.  When users interact with the bot, this
# function checks how many tokens are currently being used in the conversation. If it
# finds that the total exceeds a predefined limit, it carefully removes older messages
# from the conversation history to make room for new ones. This way, it ensures that
# only relevant and recent information is kept while still allowing for meaningful
# interactions with users.

def MaintainTokenLimit(Tokens,orgmessages,max_tokens=128000,engine='openai',model="gpt-4o",encoding=None,HuggingFace=False):
    def count_tokens():
        # Calculate current tokens in the message list
        if engine=='openai':
            current_tokens=sum(len(enc.encode(message["content"])) for message in messages)
        elif engine=='huggingface':
            current_tokens=sum(len(enc(message["content"])["input_ids"]) for message in messages)
        elif engine=='cohere':
            current_tokens=sum(len(co.tokenize(text=message["content"],model=model,offline=False).tokens) for message in messages)
        else:
            # Generic fall through. Anthropic, Perplexity do NOT have a
            # clean way of doing this... I've tried several. the 20 at the
            # end is what Anthropic calls overhead. They say 12, but as
            # wrong as the rest of this has been, the extra can not hurt.

            current_tokens=0
            for message in messages:
                if message['role']!='system':
                    current_tokens+=len(message['content'])+24
                elif engine!='anthropic':
                    current_tokens+=len(message['content'])+24
            current_tokens=int(current_tokens/4)

        return current_tokens

    try:
        if engine=='openai':
            if encoding!=None:
                enc=tiktoken.get_encoding(encoding)
            else:
                enc=tiktoken.get_encoding(tiktoken.model.MODEL_TO_ENCODING[model])
        elif engine=='huggingface' or engine=='googleai':
            enc=AutoTokenizer.from_pretrained(model)
        elif engine=='cohere':
            co=cohere.ClientV2(api_key=Tokens['Cohere'])
#        elif engine=='openrouter':
#                enc=tiktoken.encoding_for_model(model)
#        elif engine=='anthropic':
#            enc=anthropic.Anthropic(api_key=Tokens['Anthropic'])

        # Make a separate working copy of the original messages.
        messages=orgmessages.copy()

        current_tokens=count_tokens()

        old_tokens=current_tokens
        if max_tokens==0:
            return messages

        # While tokens exceed the limit, remove elements
        while current_tokens > max_tokens:
            for i in range(len(messages) - 1):
                if i < len(messages) - 1:
                    if messages[i]['role'].lower()=="user" and messages[i+1]['role'].lower()=="assistant":
                        # Remove the pair (two items)
                        messages.pop(i)
                        messages.pop(i)
                        break
                    elif messages[i]['role'].lower()=="user" and messages[i+1]['role'].lower()=="user":
                        # Remove only one item if two adjacent items are user/user
                        messages.pop(i)
                        break

            # Recalculate current tokens after removal
            current_tokens=count_tokens()
            # Check for the situation that we can't reduce the number of tokens.
            if old_tokens==current_tokens and current_tokens>max_tokens:
                return None
            old_tokens=current_tokens
    except Exception as err:
        ErrorLog(f"MaintainTokens: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

    return messages

# Get "steering" prompts, if there are any

# Steering files are a way of providing reinforcement to a pattern or paticular
# question/response designed to maintain the persona. Often times this may be used to
# enforce platform TOS/AUP.

# While we can dive into the nuances on unbiased AI material, we'll just skip to the
# finality: NOTHING IS UNBIASED. This will NEVER change simply because of how we learn,
# develop, and grow both as a family and societal structure. Bias is AUTOMATIC.

# The steering principles demonstrated here are much like we go through as children. The
# txt file will have the question repeated multiple times, with multiple acceptable
# responses. This practice is virtually identical to how we learn as children.

def GetSteering(bot,input_text):
    wordlist=GetWordList(StripPunctuation(input_text))
    if wordlist==None or wordlist==[]:
        return None

    SteerDir=f"{CompanionStorage}/{bot['BotName']}/Steering"

    try:
        for word in wordlist:
            if os.path.isdir(SteerDir+'/'+word):
                SteerDir+='/'+word
            elif os.path.isfile(SteerDir+'/'+word+'.txt'):
                prompts=ReadFile(SteerDir+'/'+word+'.txt').strip().split('\n')
                return prompts
    except Exception as err:
        ErrorLog(f"Steering: {sys.exc_info()[-1].tb_lineno}/{err}")

    # No txt file found. No prompts available
    return None

# The `GetCompanionPersona` function is responsible for determining and retrieving the
# specific personality or character traits that the bot will use when interacting with
# users in a particular Discord server.  When users send messages, it's important for
# the bot to respond in a way that fits its designated role or persona. This function
# checks the server's configuration settings to find out which persona should be used
# based on factors like the channel type and whether it’s a safe-for-work (SFW) or
# not-safe-for-work (NSFW) environment. It gathers all relevant information about how
# the bot should behave, including its name, response style, and any special rules it
# needs to follow.

def GetCompanionPersona(gid,channel,nsfw=False,Welcome=False):
    # Get the list of channels and the bot name that is allowed in a given channel
    cfg=f"{ConfigStorage}/{gid}/{gid}.cfg"
    if not os.path.exists(cfg):
        mkdir(f"{ConfigStorage}/{gid}")
        print(f'NO configuration: {cfg}')
        return None

    try:
        Config=json.loads(jsonFilter(ReadFile(cfg)))
    except Exception as err:
        ErrorLog(f"{cfg} damaged: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

    if 'Channels' not in Config:
        Config['Channels']={}

    bot=Config.copy()

    # Welcome should really be Default. If more then one bot it listed, comma separated,
    # one one random, and vwerify that it has a welcome file.

    if Welcome==True:
        bot['BotName']=Config['Welcome']
        bot['Channel']=None
    else:
        Channels=Config['Channels']
        bot['Channel']=channel
        if channel in Channels:
            bot['BotName']=Channels[channel]
            bot['ResponseAllowed']='Yes'
        else:
            bot['BotName']=Config['Default']
            bot['ResponseAllowed']='No'

    # Sort out loading a persona by channel and NSFW possibilities.

    # possibilities are that a persona can be:
    #   1. global (SFW)
    #   2. global, NSFW
    #   3. channel, (SFW)
    #   4. channel, NSFW

    # System Role
    # Test channel NSFW
    BotSystem=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.{channel}.system.nsfw"
    if nsfw and os.path.exists(BotSystem):
        bot['System']=BotSystem
    else:
        # Test channel SFW
        BotSystem=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.{channel}.system"
        if os.path.exists(BotSystem):
            bot['System']=BotSystem
        else:
            # Test global NSFW
            BotSystem=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.system.nsfw"
            if nsfw and os.path.exists(BotSystem):
                bot['System']=BotSystem
            else:
                # global SFW
                bot['System']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.system"

    # Persona file
    # Test channel NSFW
    BotPersona=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.{channel}.persona.nsfw"
    if nsfw and os.path.exists(BotPersona):
        bot['Persona']=BotPersona
    else:
        # Test channel SFW
        BotPersona=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.{channel}.persona"
        if os.path.exists(BotPersona):
            bot['Persona']=BotPersona
        else:
            # Test global NSFW
            BotPersona=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.persona.nsfw"
            if nsfw and os.path.exists(BotPersona):
                bot['Persona']=BotPersona
            else:
                # global SFW
                bot['Persona']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.persona"

    bot['Welcome']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.welcome"
    bot['Vulgarity']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.vulgarity"
    bot['ScamURLS']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.scamurls"
    bot['AutoFilter']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.autofilter"
    bot['AgeExploit']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.ageexploit"
    bot['PII']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.pii"
    bot['TooMuchInformation']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.tmi"
    bot['Broken']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.broke"
    bot['URLBroken']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.urlbroke"
    bot['YTtags']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.yttags"
    bot['noYTtags']=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.noyttags"

    # Load bot config file. Channel CFg always has priority.
    settings={}
    try:
        bcfg=f"{ConfigStorage}/{gid}/{bot['BotName']}.{channel}.cfg"
        if os.path.exists(bcfg):
            settings=json.loads(jsonFilter(ReadFile(bcfg)))
        else:
            bcfg=f"{ConfigStorage}/{gid}/{bot['BotName']}.cfg"
            if os.path.exists(bcfg):
                settings=json.loads(jsonFilter(ReadFile(bcfg)))
    except Exception as err:
        ErrorLog(f"{bcfg} damaged: {sys.exc_info()[-1].tb_lineno}/{err}")

    # Merge the persona settings into the controlling dictionary
    if settings!={}:
        bot|=settings

    # Run through some sanity checks.
    if 'AutoLogging' not in bot:
        bot['AutoLogging']='yes'
    if 'AutoModeration' not in bot:
        bot['AutoModeration']='yes'
    if 'PIIModeration' not in bot:
        bot['PIIModeration']='yes'
    if 'AllowBot' not in bot:
        bot['AllowBot']='no'
    if 'Engine' not in bot:
        bot['Engine']="openai"
    if 'Model' not in bot:
        bot['Model']="gpt-4o-mini"
    if 'FreqPenality' not in bot:
        bot['FreqPenality']=0.67
    else:
        if type(bot['FreqPenality'])!=float:
            bot['FreqPenality']=float(bot['FreqPenality'])
    if 'Temperature' not in bot:
        bot['Temperature']=0.37
    else:
        if type(bot['Temperature'])!=float:
            bot['Temperature']=float(bot['Temperature'])
    if 'AllowVulgarity' not in bot:
        bot['AllowVulgarity']='No'
    if 'MaxMemory' not in bot:
        bot['MaxMemory']=100
    else:
        if type(bot['MaxMemory'])!=int:
            bot['MaxMemory']=int(bot['MaxMemory'])

    # return the current bot
    return bot

# The `GetBabble` function is designed to manage the interaction between users and the
# AI within a Discord server. When a user sends a message to the bot, this function
# takes that message and prepares it for processing by the AI.  Here's how it works:
# when a message is received, `GetBabble` gathers all relevant information, including
# who sent the message and which channel it was sent in. It then compiles this
# information along with any previous context or conversation history. This complete
# package is then sent to the AI for generating an appropriate response.

def GetBabble(message,text):
    try:
        # The "uid" and "channel" are used to load the persona and store the memory to
        # disk. At this point, we don't have any global variables.

        # EXTEND to: GuildID/ChannelID:NSFW/MessageID/UID/input

        dataline=text.split('/')
        gid=message.guild.id
        uid=dataline[0]
        channel,cnsfw=dataline[1].split(':')
        nsfw=(cnsfw=='T')
        input_text=str(dataline[2:]).replace("'","\'").replace('"',"'")

        # Don't remember this request. does NOT bypass logging

        ForgetThisMessage=False
        if text.strip().startswith('%#>'):
            ForgetThisMessage=True
            input_text=input_text[3:]

        # Load the persona and memory files
        # NSFW not allowed in threads directly, so find parent channel

        # Question: Do we take info of NSFW state or force verify? Currebt is
        # face value

        bot=None
        if isinstance(message.channel,discord.Thread):
            pchannel=str(message.channel.parent)
            bot=GetCompanionPersona(gid,pchannel,nsfw)   # message.channel.parent.nsfw
        else:
            bot=GetCompanionPersona(gid,channel,nsfw)

        persona=[]
        mList=[]

        # Read system role from system tag file
        # { "role": "system", "content": ""}

        if os.path.exists(bot['System']):
            buff=ReadFile(bot['System']).replace('\n','\\n').replace("'","\'").replace('"',"'").strip()
            sysList=[ '{'+ f'"role": "system", "content": "{buff}"' +'}' ]
        else:
            sysList=[]

        # Read the persona file
        if os.path.exists(bot['Persona']):
            pfList=ReadFile(bot['Persona']).strip().split('\n')
        else:
            pfList=[]
        pList=sysList+pfList

        # Load memory files, if one exists.
        dn=f"{MemoryStorage}/{gid}/{bot['BotName']}"
        mkdir(dn)
        fn=f"{dn}/{bot['BotName']}.{uid}.{channel}.memory"
        if os.path.exists(fn):
            mList=ReadFile(fn).strip().split('\n')
            pList+=mList

        # Build the complete persona list

        for s in pList:
            try:
                persona.append(json.loads(s))
            except:
                ErrorLog(f"Broke: {sys.exc_info()[-1].tb_lineno}/{s}")

        # Look for a "steering" file. Should be last to ensurew its not chopped of.
        sList=GetSteering(bot,input_text)
        if sList!=None:
            pList+=sList

        # Add user input

        memU={ "role": "user", "content": input_text }
        persona.append(memU)

        # Process API for the request

        el=list(bot['Engine'].split(','))       # Engine list
        ec=len(el)                              # Engine list length
        tl=list(bot['MaxTokens'].split(','))    # Max Tokens list
        mt=len(tl)                              # Max Tokens list length
        # Encoding alwayys takes priority over modem
        if 'Encoding' in bot:
            ml=list(bot['Encoding'].split(','))        # Model list
            mc=len(ml)                              # Model list length
        else:
            ml=list(bot['Model'].split(','))        # Model list
            mc=len(ml)                              # Model list length

        # The number of models MUST equal the number of engines. 1 model per engine

        if ec!=mc!=mt:
            ErrorLog(f"Broke GB ((models/Encoding)!=engines!=MaxTokens): {sys.exc_info()[-1].tb_lineno}/{err}")
            return PickRandomResponse(bot['Broken'])

        # Run through the engins/models until we have a response.

        response=None
        ecounter=0
        while response==None and ecounter<ec:
            cbot=copy.deepcopy(bot)             # Make a copy
            cbot['Engine']=el[ecounter]
            cbot['MaxTokens']=int(tl[ecounter])
            # Encoding or Model
            if 'Encoding' in cbot:
                cbot['Encoding']=ml[ecounter]
            else:
                cbot['Model']=ml[ecounter]

            startTime=time.time()
            response=GetAIResponse(gid,persona,cbot)
            endTime=time.time()
            AppendFile(f'{LoggingStorage}/{gid}.timing',f"{datetime.datetime.fromtimestamp(startTime).strftime('%Y-%m-%d %H:%M:%S')} {cbot['Engine']} {cbot['Model']} {endTime-startTime:.6f}\n")
            if response==None:
                ecounter+=1
            else:
                break

        # check to see if we got a response. If not, don't save the
        # memory, just return.

        if response==None or response=='':
            return PickRandomResponse(bot['Broken'])

        # Save "memory" to disk

        memA={ "role": "assistant", "content": response }

        mList.append(json.dumps(memU))
        mList.append(json.dumps(memA))

        # Keep memory at a limited amount. The *2 is because we are saving user and AI
        # responses.

        if bot['MaxMemory']>0 and memA['content']!=None and not ForgetThisMessage:
            if len(mList)>(bot['MaxMemory']*2):
                mList=mList[2:]

            fh=open(fn,'w')
            for i in mList:
                fh.write(i+'\n')
            fh.close()

        # Return the AI response

        return response
    except Exception as err:
        ErrorLog(f"Broke GB: {sys.exc_info()[-1].tb_lineno}/{err}")
        return PickRandomResponse(bot['Broken'])

# The `HandleOneMessage` function is designed to take care of individual messages sent
# to the bot in a Discord server. When a user sends a message, this function steps in to
# manage the entire process of understanding and responding to that message.  Here's how
# it works: when a message is received, the function first gathers all necessary
# details, such as who sent the message and which channel it was sent in. It then checks
# if there are any specific rules or settings that need to be applied based on the
# context (like whether it's a safe-for-work environment). After that, it prepares
# everything needed for the AI to generate an appropriate response.

async def HandleOneMessage(request):
    with concurrent.futures.ThreadPoolExecutor() as pool:
        try:
            input_text=request['input']
            guild=client.get_guild(request['gid'])
            channel=await guild.fetch_channel(request['cid'])
            message=await channel.fetch_message(request['mid'])

            uid=str(message.author.id)
            author=str(message.author.mention)
            channel=str(message.channel)

            # NSFW not allowed in threads, so find parent channel
            bot=None
            if isinstance(message.channel,discord.Thread):
                pchannel=message.channel.parent
                bot=GetCompanionPersona(guild.id,str(pchannel),pchannel.nsfw)
                nsfw=str(pchannel.nsfw)[0]
                # WTAF? Really? bots have to join a thread...
                if not message.channel.me:
                    await message.channel.join()
            else:
                bot=GetCompanionPersona(guild.id,str(message.channel),message.channel.nsfw)
                nsfw=str(message.channel.nsfw)[0]
            if bot==None:
                return

            # Convert boolean to str as a passing argument.
            print('U',guild.id,nsfw,uid,message.author,message.channel,len(message.content))

            # Handle any vulgarity
            if bot['AutoModeration'].lower()!='no' \
            and os.path.exists(bot['Vulgarity']) \
            and bot['AllowVulgarity'].lower()=='no' \
            and not nsfw=='T':
                if bool(pc.predict([ input_text ]))==True:
                    await ModeratorNotify(bot,message.guild,f"{message.author.name}/{message.author.id} chastized for vulgarity in {message.channel.name}")
                    await send_response(bot,message,PickRandomResponse(bot['Vulgarity']),delete=57)
                    try: # delete the offending message
                        await message.delete()
                    except:
                        pass
                    return
                else:
                    istr=f"{uid}/{channel}:{nsfw}/{input_text}"
                    response=await client.loop.run_in_executor(pool, GetBabble,message, istr)
            else:
                istr=f"{uid}/{channel}:{nsfw}/{input_text}"
                response=await client.loop.run_in_executor(pool, GetBabble,message, istr)

            print('B',guild.id,client.user.id,bot['BotName'],message.channel,len(response))

            # Check to see if we actually got a response
            if response!=None and response.lower().strip()!="none":
                # Handle webhooks for response
                await send_response(bot,message,response)
            else:
                # Communication with AI failed. Put message back in queue
                if ResponseLock.acquire(timeout=ResponseTimeout):
                    msg={}
                    msg['gid']=guild.id
                    msg['cid']=message.channel.id
                    msg['mid']=message.id
                    msg['input']=input_text
                    PutNextRequest(guild.id,msg)
                    ResponseLock.release()
                else:
                    ErrorLog("Lock failed Reput Message")
        except Exception as err:
            ErrorLog(f"Broken HandleOneMessage: {sys.exc_info()[-1].tb_lineno}/{err}")

# The `GetNextRequest` function is designed to retrieve the next request from a specific
# Discord server's list of messages that need to be processed by the AI.  When users
# interact with the bot and send messages, those messages are collected in a queue so
# that they can be handled one at a time. This function looks at this queue and pulls
# out the first request that is waiting to be addressed. By doing this, it ensures that
# each message is processed in order, allowing the AI to respond appropriately and
# maintain smooth communication.

def GetNextRequest(gid):
    try:
        rname=f"{MemoryStorage}/{gid}/requests.txt"

        if not os.path.exists(rname):
            return None

        # Read request list for a specific server
        request_list=ReadFile(rname).strip().split('\n')
        # Get first request
        try:
            request=json.loads(request_list[0])
        except Exception as err:
            ErrorLog(f"Broken request: {sys.exc_info()[-1].tb_lineno}/{err}")
            return None

        # Write the rest of the list back to disc. This is the file version of
        # popping the first item.

        if (len(request_list)-1)>0:
            fh=open(rname,'w')
            for i in range(1,len(request_list)):
                fh.write(request_list[i]+'\n')
            fh.close()
        else:
            os.remove(rname)

        return request
    except Exception as err:
        ErrorLog(f"GNR: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

# The `PutNextRequest` function is responsible for adding a new request to a specific
# Discord server's list of messages that need to be processed by the AI.  When users
# send messages to the bot, those messages may require thoughtful responses from the AI.
# This function takes each new message and places it at the end of the queue, ensuring
# that it will be addressed in turn after any previous requests. By doing this, it helps
# manage how and when each message is handled, allowing for organized communication.

def PutNextRequest(gid,msg):
    rname=f"{MemoryStorage}/{gid}/requests.txt"
    s=json.dumps(msg)+'\n'
    AppendFile(rname,s)

###
### AI handlers (Optimized)
###

# Get a response from OpenAI directly. Should not depend on bot structure,
# for classifiers.

def GetOpenAI(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        clientAI=openai.OpenAI(api_key=apikey)
        completion=clientAI.chat.completions.create(
                model=model,
                frequency_penalty=freqpenality,
                temperature=temperature,
                messages=messages,
                timeout=timeout
            )
        clientAI.close()
        response=completion.choices[0].message.content.strip()
        RawLog(f"OpenAI/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"OpenAI {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

# Get response from OpwenRouter using OpenAI interface

def GetOpenRouter(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        clientAI=openai.OpenAI(api_key=apikey,base_url="https://openrouter.ai/api/v1")
        completion=clientAI.chat.completions.create(
                model=model,
                frequency_penalty=freqpenality,
                temperature=temperature,
                messages=messages,
                timeout=timeout
            )
        clientAI.close()
        response=completion.choices[0].message.content.strip()
        RawLog(f"OpenRouter/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"OpenRouter {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetAnthropic(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        clientAI=anthropic.Anthropic(api_key=apikey,timeout=timeout)
        completion=clientAI.messages.create(
                system=messages[0]['content'],
                model=model,
                max_tokens=4096,
                temperature=temperature,
                messages=messages[1:],
                stream=False
            )
        clientAI.close()
        response=completion.content[0].text.strip()
        RawLog(f"Anthropic/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"Anthropic {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetHuggingFace(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        clientAI=InferenceClient(token=apikey,timeout=timeout)
        completion=clientAI.chat.completions.create(
                model=model,
                frequency_penalty=freqpenality,
                temperature=temperature,
                messages=messages,
                stream=False
            )
        stop=completion.choices[0].finish_reason
        response=completion.choices[0].message.content.strip()
        RawLog(f"HuggingFace/{model}: {str(completion)}")
        return response,stop
    except Exception as err:
        ErrorLog(f"HuggingFace {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetTogetherAI(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        clientAI=together.Together(api_key=apikey, timeout=timeout)
        completion=clientAI.chat.completions.create(
                model=model,
                frequency_penalty=freqpenality,
                temperature=temperature,
                messages=messages,
                stream=False
            )
        response=completion.choices[0].message.content.strip()
        RawLog(f"TogetherAI/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"TogetherAI {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetCohere(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        co=cohere.ClientV2(api_key=apikey, timeout=timeout)
        completion=co.chat(
                model=model,
                frequency_penalty=freqpenality,
                temperature=temperature,
                messages=messages,
                safety_mode="NONE"
            )
        response=completion.message.content[0].text.strip()
        RawLog(f"Cohere/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"Cohere {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetOllama(apikey,messages,model,freqpenality,temperature,timeout,seed=0,mt=2048):
    try:
        options={
                "temperature": temperature,
                "frequency_penalty": freqpenality,
                "seed": seed,
                "num_ctx": mt
            }
        completion=ollama.chat(
                keep_alive=timeout,
                stream=False,
                model=model,
                options=options,
                messages=messages
            )
        response=completion['message']['content'].strip()
        RawLog(f"Ollama/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"Ollama {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

def GetPerplexity(apikey,messages,model,freqpenality,temperature,timeout):
    try:
        # Prepare the payload for the request
        payload = {
                "model": model,
                "messages": messages,
                "temperature": temperature,
            }

        # Perplexity URL
        PerplexityURL = "https://api.perplexity.ai/chat/completions"

        # Set up headers including authorization
        headers = {
                "Authorization": f"Bearer {apikey}",
                "Content-Type": "application/json"
            }

        # Make the POST request to the Perplexity API
        response=requests.post(PerplexityURL, json=payload, headers=headers,timeout=timeout)

        # Check if the request was successful
        if response.status_code==200:
            completion=response.json()

        response=completion["choices"][0]["message"]["content"].strip()

        # If there are citations in the choices text portion, append
        # them to the response. This is not neccessary, but it does look
        # nice and adds to the bot's presence.

        IsCitations=any(re.search(r'\[\d+\]', choice.get("message", {}).get("content", "")) for choice in completion.get("choices", []))
        if IsCitations:
            response+="\n\n"+"\n".join(f"<{url}>" for url in completion['citations'])
        RawLog(f"Perplexity/{model}: {str(completion)}")
        return response
    except Exception as err:
        ErrorLog(f"Perplexity {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

# The `GetAIResponse` function is responsible for communicating with the
# AI to generate thoughtful replies based on user messages. When a user
# sends a message to the bot, this function takes all relevant
# information—like the context of the conversation and any specific
# instructions—and sends it to the AI service.  Here's how it works: once
# the necessary details are gathered, this function makes a request to the
# appropriate AI provider (such as OpenAI or Hugging Face) using their
# API. It specifies parameters like which model to use and how creative or
# focused the response should be. After sending this request, it waits for
# a reply from the AI.

def GetAIResponse(gid,persona,bot):
    print(gid,bot.get('Model'), bot.get('Encoding'))
    provider=bot.get('Engine').lower()

    # HuggingFace uses mutiple responses...
    hfresponses=[]

    try:
        # Default connection timeout
        tout=bot.get('Timeout', 60)
        mt=bot.get('MaxTokens', 2048 if provider=='ollama' else 4096)
        model=bot.get('Model')
        encoding=bot.get('Encoding')
        seed=bot.get('Seed', 0)

        # Provider-specific handling
        Tokens=ReadTokens(gid)

        # Adjust persona based on token limit
        WorkingPersona=MaintainTokenLimit(Tokens, persona, max_tokens=mt, engine=provider, model=model, encoding=encoding, HuggingFace=(provider != 'openai'))
        if WorkingPersona is None:
            return PickRandomResponse(bot['TooMuchInformation'])

        if provider=='openai':
           response=GetOpenAI(Tokens['OpenAI'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='openrouter':
           response=GetOpenRouter(Tokens['OpenRouter'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='anthropic':
           response=GetAnthropic(Tokens['Anthropic'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='togetherai':
            response=GetTogetherAI(Tokens['TogetherAI'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='cohere':
            response=GetCohere(Tokens['Cohere'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='ollama':
           response=GetOllama(None,WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout,seed=seed,mt=mt)
        elif provider=='perplexity':
          response=GetPerplexity(Tokens['Perplexity'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
        elif provider=='huggingface':
            # HuggingFace uses fragmentation for completion methods...
            # Access is free for 1000 requests per day. 1 response could
            # take 8 requests to the API.
            while True:
                resp,stop=GetHuggingFace(Tokens['HuggingFace'],WorkingPersona,model,bot['FreqPenality'],bot['Temperature'],tout)
                hfresponses.append(resp)

                # Emulate user typing continue. Count tokens as well...
                WorkingPersona.append({"role":"assistant", "content":resp})
                WorkingPersona.append({"role":"user", "content":"Continue"})
                WorkingPersona=MaintainTokenLimit(Tokens, WorkingPersona, max_tokens=mt, engine=provider, model=model, encoding=encoding, HuggingFace=(provider != 'openai'))
                if WorkingPersona is None:
                    return PickRandomResponse(bot['TooMuchInformation'])

                # if finish reason is length, response is fragmented.
                print("HuggingFace fragment:",stop,len(resp))
                if stop!='length' or len(resp)==0:
                    break
            response=' '.join(hfresponses).strip()
        # Engine not recognized.
        else:
            return None

        return response
    except Exception as err:
        ErrorLog(f"{provider} {model}: {sys.exc_info()[-1].tb_lineno}/{err}")
        return None

###
### Special features
###

# The `AnagramSolver` function is designed to help users find all possible words that
# can be created by rearranging a set of letters. When a user provides a string of
# letters, this function analyzes those letters and searches through a dictionary of
# valid words to identify which ones can be formed.  Here's how it works: the function
# takes the input letters and generates various combinations and permutations. It then
# checks each combination against a list of known words to see if they match any valid
# entries. The results are organized by word length, allowing users to see which words
# can be created from their given letters.

def AnagramSolver(fromletters):
    def load_dictionary(file_path):
        # Load dictionary words from a file and return them as a set.
        with open(file_path, 'r') as f:
            words=set(word.strip().lower() for word in f.readlines())
        return words

    def find_valid_words_by_length(letters, dictionary):
        # Find all valid words from combinations and permutations of the input letters
        # grouped by length.

        valid_words={}

        # Generate combinations of letters from 3 to the length of the input
        for length in range(3, len(letters) + 1):
            for combo in itertools.combinations(letters, length):
                # For each combination, generate all permutations
                for perm in itertools.permutations(combo):
                    word=''.join(perm)
                    if word in dictionary:
                        if length not in valid_words:
                            valid_words[length]=set()
                        valid_words[length].add(word)
        # Sort each length's word list alphabetically
        for length in valid_words:
            valid_words[length]=sorted(valid_words[length])
        return valid_words

    # Load letters from the command line argument
    letters=fromletters.lower()

    # Load dictionary from the dictionary.txt file
    dictionary=load_dictionary(AnagramWordList)

    # Find valid words from the provided letters, grouped by length
    valid_words_by_length=find_valid_words_by_length(letters, dictionary)

    # Sorting the dictionary by word length in descending order and printing results
    wstr=''
    for length in sorted(valid_words_by_length.keys(), reverse=True):
        wstr+=f"**Words of length {length}**:\n"
        wstr+=' '.join(valid_words_by_length[length])+'\n\n'
    return wstr

# Read tags from a YouTube video

def yttags2text(url):
    def extract_video_id(url):
        # Match either a youtu.be or youtube.com URL to extract the video ID
        youtube_regex=r"(?:youtu\.be\/|youtube\.com\/(?:.*v=|.*\/|.*v\/|.*embed\/|.*shorts\/))([a-zA-Z0-9_-]{11})"
        match=re.search(youtube_regex, url)

        if match:
            return match.group(1)
        else:
            return None

    def get_video_tags(video_id):
        # Fetch video details including tags
        try:
            request=youtube.videos().list(
                part="snippet",
                id=video_id
            )
        except Exception as err:
            ErrorLog(f"Broke yttags: {sys.exc_info()[-1].tb_lineno}/{err}")
            return '{[(*VNF*)]}'

        response=request.execute()

        if "items" in response and len(response["items"]) > 0:
            video_snippet=response["items"][0]["snippet"]
            if "tags" in video_snippet:
                tags=video_snippet["tags"]
                return tags
            else:
                return None
        else:
            return '{[(*VNF*)]}'

    try:
        # Create YouTube Object
        youtube=build('youtube', 'v3', developerKey=Tokens['YouTube'])

        # Retrieve and display tags
        tags=get_video_tags(extract_video_id(url))

        if isinstance(tags, list):
            return '\n'.join(tags)
        return tags
    except Exception as err:
        ErrorLog(f"Broke yttags: {sys.exc_info()[-1].tb_lineno}/{err}")
        return '{[(*VNF*)]}'

# Read a YouTube URL and pull the transcript

def youtube2text(video_url):
    try:
        # Extract the video ID from the URL
        #video_id=video_url.split('v=')[1]
        video_id=re.search(r'(v=|be/|embed/|v/|youtu\.be/|\/videos\/|\/shorts\/|\/watch\?v=|\/watch\?si=|\/watch\?.*?&v=)([a-zA-Z0-9_-]{11})',video_url).group(2)

        # Fetch the transcript using the YouTubeTranscriptApi
        transcript_list=youtube_transcript_api.YouTubeTranscriptApi.get_transcript(video_id)

        # Use the TextFormatter to convert the transcript into plain text
        transcript_text='\n'.join(line['text'] for line in transcript_list)

        return 'Video Transcript: '+transcript_text
    except Exception as err:
        ErrorLog(f"Broke youtube2text: {sys.exc_info()[-1].tb_lineno}/{err}")
    return None

# Read PDF from buffer

def PDF2Text(pdf_buffer):
    with pdfplumber.open(io.BytesIO(pdf_buffer)) as pdf:
        text=""
        for page in pdf.pages:
            text+=page.extract_text()
        return 'PDF Content: '+text

# Get a URL and scrub it to pure text

def html2text(url):
    try:
        # Set the user agent
        headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}
        request=urllib.request.Request(url, headers=headers)

        print("Fetch:",url)

        # Video transcript?
        if 'youtube.com/watch' in url or 'youtu.be/' in url:
            input_text=youtube2text(url)
            return input_text

        # Not a YouTube transcript, Fetch the HTML content from the URL

        try:
            with urllib.request.urlopen(request,timeout=60) as response:
                html=response.read()
        except Exception as err:
            print("URL Error:",url,str(err))
            return None

        if response.code>=400:
            print("URL Code:",response.code,url)
            return None

        # Check for PDF signature
        if html[:5]=='%PDF-':
            text=PDF2Text(html).strip()
            print("PDF:",len(text),url)
            return text

        # Decoding MUST be done AFTER pdf test
        html=html.decode('utf-8',errors='ignore')

        # Remove the entire head section
        html=re.sub(r'<head.*?>.*?</head>', '', html, flags=re.DOTALL)

        # Remove script and style elements
        html=re.sub(r'<(script|style).*?>.*?</\1>', '', html, flags=re.DOTALL)

        # Reduce <a> elements to their text content
        html=re.sub(r'<a[^>]*>(.*?)</a>', r'\1', html, flags=re.DOTALL)

        # Remove all other HTML tags
        text=re.sub(r'<[^>]+>', '', html)

        # Remove extra whitespace
        text=re.sub(r'\s+', ' ', text).strip()

        print("URL:",len(text),url)

        return 'Web Page Content: '+text
    except Exception as err:
        ErrorLog(f"Broke html2text: {sys.exc_info()[-1].tb_lineno}/{err}")

    return None

###
### Discord support functions
###

# Disect discord messages. Forensic logging

def DisectMessage(event,message):
    if DisectLock.acquire(timeout=DisectTimeout):
        # Set up convience variables
        gid=message.guild.id
        channel=str(message.channel)
        uid=str(message.author.id)
        author=message.author
        member=message.guild.get_member(author.id) if message.guild else None
        nickname=member.nick if member and member.nick else author.name

        try:
            # Checking different channel types with isinstance
            if isinstance(message.channel, discord.TextChannel):
                insttype="Text Channel"
            elif isinstance(message.channel, discord.VoiceChannel):
                insttype="Voice Channel"
            elif isinstance(message.channel, discord.Thread):
                insttype="Thread"
            elif isinstance(message.channel, discord.DMChannel):
                insttype="Direct Message"
            elif isinstance(message.channel, discord.CategoryChannel):
                insttype="Category Channel"
            else:
                insttype="Unknown Channel"

            WriteLog(gid,uid,channel,f"Event trigger: {event}")
            WriteLog(gid,uid,channel,f"Message: {message.id}/{message.type}/{insttype}")
            WriteLog(gid,uid,channel,f"Message Timestamp: {message.created_at}/{message.edited_at if message.edited_at else 'Not Edited'}")
            WriteLog(gid,uid,channel,f"Message Pinned: {message.pinned}")
            WriteLog(gid,uid,channel,f"Message Author: {message.author.name}#{message.author.discriminator}/{nickname}/{author.display_name}/{message.author.id} Bot: {message.author.bot}")
            WriteLog(gid,uid,channel,f"Message Channel: {message.channel.name}/{message.channel.id}")
            WriteLog(gid,uid,channel,f"Message Guild: {message.guild.name if message.guild else 'DM'}/{message.guild.id if message.guild else 'DM'}")
            # Check if the message was sent via a webhook
            if message.webhook_id:
                WriteLog(gid,uid,channel,f"Message sent via Webhook ID: {message.webhook_id}")
            # List the users mentioned, if any
            if message.mentions:
                WriteLog(gid,uid,channel,f"Message Mentions: {[str(user) for user in message.mentions]}")
            if message.role_mentions:
                WriteLog(gid,uid,channel,f"Message Mentioned Roles: {[role.name for role in message.role_mentions]}")
            if message.channel_mentions:
                WriteLog(gid,uid,channel,f"Message Mentioned Channels: {[channel.name for channel in message.channel_mentions]}")
            if str(message.content).strip()!='':
                WriteLog(gid,uid,channel,f"Message Content: {message.content}")
            else:
                WriteLog(gid,uid,channel,f"Message Content: Empty content field")
            if message.reactions:
                WriteLog(gid,uid,channel,f"Message Reactions: {[(reaction.emoji, reaction.count) for reaction in message.reactions]}")

            # Log sticker information
            if message.stickers:
                WriteLog(gid,uid, channel, f"Message Stickers: {[{'name': sticker.name, 'id': sticker.id} for sticker in message.stickers]}")

            # Log reference information (for replies)
            if message.reference:
                ref=message.reference
                WriteLog(gid,uid, channel, f"Message is a Reply to: {ref.message_id} in Channel: {ref.channel_id} of Guild: {ref.guild_id}")

            # Log details about each embed
            if message.embeds:
                WriteLog(gid,uid,channel,f"Message Embeds: {len(message.embeds)} embeds")
                for index, embed in enumerate(message.embeds):
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Title: {embed.title}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Type: {embed.type}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Description: {embed.description}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} URL: {embed.url}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Timestamp: {embed.timestamp}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Color: {embed.color}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Footer: {embed.footer.text if embed.footer else 'None'}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Image: {embed.image.url if embed.image else 'None'}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Thumbnail: {embed.thumbnail.url if embed.thumbnail else 'None'}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Author: {embed.author.name if embed.author else 'None'}")
                    WriteLog(gid,uid, channel, f"Embed {index + 1} Fields: {[{'name': field.name, 'value': field.value} for field in embed.fields]}")

            # Log detailed information about each attachment
            if message.attachments:
                WriteLog(gid,uid,channel,f"Message Attachments: {[attachment.url for attachment in message.attachments]}")
                for index, attachment in enumerate(message.attachments):
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} Filename: {attachment.filename}")
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} Size: {attachment.size} bytes")
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} URL: {attachment.url}")
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} Proxy URL: {attachment.proxy_url}")
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} Height: {attachment.height if attachment.height else 'N/A'}")
                    WriteLog(gid,uid, channel, f"Attachment {index + 1} Width: {attachment.width if attachment.width else 'N/A'}")

            # Log message components (if any)
            if message.components:
                WriteLog(gid,uid, channel, f"Message Components: {[{'type': component.type, 'custom_id': component.custom_id} for component in message.components]}")
            WriteLog(gid,uid,channel,f"{'-'*80}")
        except AttributeError as e:
            WriteLog(gid,uid,channel,f"Error accessing message attributes: {e}")
        DisectLock.release()

# Change the nick name and avatar

async def ChangeNickAvatar(bot,message):
    # Only change avatar if channels change.
    channel=str(message.channel)
    cname=ReadFile(RunningName+'.lastchannel')
    if cname==None or channel.strip()!=cname:
        WriteFile(RunningName+'.lastchannel',channel+'\n')

        # Only seems to work with Administrator priviledges
        # Change the nickname if the bot.
        try:
            # Add code to check avatar name and channel. Only change avatar when
            # channel changes.
            await message.guild.me.edit(nick=bot['BotName'])
            pname=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.png"
            png=ReadFile(pname,binary=True)
            await client.user.edit(avatar=png)
        except Exception as err:
            ErrorLog(f"Broken Nick/Avatar: {sys.exc_info()[-1].tb_lineno}/{err}")

# The `send_response` function is responsible for sending messages from the bot back to
# users in a Discord channel. When the bot generates a reply—whether it’s an answer to a
# question, information, or an alert—this function takes care of delivering that message
# appropriately.  Here's how it works: the function checks where the response should be
# sent, whether it's in a regular chat channel or a thread. It formats the message and
# can even include special features like embeds (which are visually appealing message
# components) to enhance how information is presented. If needed, it can also schedule
# messages for automatic deletion after a certain period.

async def send_response(bot,message,response,embed=None,delete=None,member=None):
    global delete_list
    whmsg=[]

    try:
        if bot['Channel']==None:
            webhooks=await member.guild.system_channel.webhooks()
        else:
            # If its a thread, get the parent channel
            pchannel=message.channel
            if isinstance(message.channel,discord.Thread):
                pchannel=message.channel.parent
            webhooks=await pchannel.webhooks()

        # Delete all webhooks with the name "Companion Temporary Webhook"
        for webhook in webhooks:
            if webhook.name=='Companion Temporary Webhook':
                await webhook.delete()

        threadID=None
        # Create a new webhook
        if bot['Channel']==None:
            syschannel=member.guild.system_channel
            webhook=await syschannel.create_webhook(name='Companion Temporary Webhook')
            author=None
        else:
            # Handle thread issues, get parent channel
            pchannel=message.channel
            if isinstance(message.channel,discord.Thread):
                pchannel=message.channel.parent
            webhook=await pchannel.create_webhook(name='Companion Temporary Webhook')
            # Get the name of the person this message is going to
            author=str(message.author.mention)
            if isinstance(message.channel,discord.Thread):
                threadID=message.channel # Actual thread ID

        # If the message is less then 1900 characters, just send it with a reply.
        if embed!=None:
            if author!=None:
                x1=f"{author}"
            else:
                x1=''
            if threadID:
                wm=await webhook.send(content=x1,embed=embed,username=bot['BotName'],avatar_url=bot['Avatar'],thread=threadID,wait=True)
            else:
                wm=await webhook.send(content=x1,embed=embed,username=bot['BotName'],avatar_url=bot['Avatar'],wait=True)
            whmsg.append(wm)
        elif len(response)<=1900:
            if author!=None:
                x1=f"{author} {response}"
            else:
                x1=f"{response}"
            # sending with and without threads must be separate
            if threadID:
                wm=await webhook.send(content=x1,username=bot['BotName'],avatar_url=bot['Avatar'],thread=threadID,wait=True)
            else:
                wm=await webhook.send(content=x1,username=bot['BotName'],avatar_url=bot['Avatar'],wait=True)
            whmsg.append(wm)
        else:

            # Break this up into multiple messages. Discord does NOT allow
            # direct reply with multiple message parts.

            x1=f"{author} {response}"
            l=len(x1)
            while l>1900:
                # We need to deal with the possibility that a \n doesn't exist in the input data.
                pmax=1900
                # Look for new line first
                p=x1.rfind('\n',0,pmax)
                if p==-1:
                    # Look for a period  Separate at a sentence
                    p=x1.rfind('.',0,pmax)
                    if p==-1:
                        # Look for a space  Separate at a word
                        p=x1.rfind(' ',0,pmax)
                        if p==-1:
                            # Brute split
                            pmax=1900
                if len(x1[:p])>0:
                    if threadID:
                        wm=await webhook.send(content=x1[:p].strip(),username=bot['BotName'],avatar_url=bot['Avatar'],thread=threadID,wait=True)
                    else:
                        wm=await webhook.send(content=x1[:p].strip(),username=bot['BotName'],avatar_url=bot['Avatar'],wait=True)
                    whmsg.append(wm)
                if x1[p]=='.' or x1[p]==' ':
                    p+=1
                x1=x1[p:].strip()
                l=len(x1)
            if l>0:
                if threadID:
                    wm=await webhook.send(content=x1.strip(),username=bot['BotName'],avatar_url=bot['Avatar'],thread=threadID,wait=True)
                else:
                    wm=await webhook.send(content=x1.strip(),username=bot['BotName'],avatar_url=bot['Avatar'],wait=True)
                whmsg.append(wm)

        # Queue autodelete messages. Responses can be multiple messages.
        if delete!=None:
            if DeleteLock.acquire(timeout=DeleteTimeout):
                for whm in whmsg:
                    delete_list.append({"gid": whm.guild.id,"cid":whm.channel.id,"mid":whm.id,"Expires":whm.created_at.timestamp()+delete } )
                DeleteLock.release()
            else:
                ErrorLog("Lock failed SR autodelete")
        # Delete the webhook
        await webhook.delete()
    except discord.errors.HTTPException as err:
        ErrorLog(f'Error sending message: {sys.exc_info()[-1].tb_lineno}/{err}')
    except Exception as err:
        ErrorLog(f'Error sending message: {sys.exc_info()[-1].tb_lineno}/{err}')

# Post message is moderation area

async def ModeratorNotify(bot,guild,text):
    # If there is a moderator area, send a message to it.
    if 'ModerationArea' in bot:
        for channel in guild.channels:
            if isinstance(channel,discord.TextChannel) and channel.name==bot['ModerationArea']:
                await channel.send(text)
                break

# Verify the CompanionAdministration channel exists and is set to the
# owner role.

async def VerifyCompanionAdministration(guild):
    try:
        # Create the owner role if not present
        orole=discord.utils.get(guild.roles,name='owner')
        if not orole:
            # create the owner role
            orole=await guild.create_role(name='owner', \
                permissions=discord.Permissions(read_messages=True,send_messages=True), \
                mentionable=False,color=discord.Color(0xFF0000))

            # assign it to thew owner
            if orole not in guild.owner.roles:
                await guild.owner.add_roles(orole)

        # Check for the 'companion-administration' channel
        channel=discord.utils.get(guild.text_channels, name='companion-administration')

        # Set up default security
        overwrites={ guild.default_role: discord.PermissionOverwrite( view_channel=False,
                        send_messages=False,read_messages=False,read_message_history=False,
                        mention_everyone=False,add_reactions=False,attach_files=False,
                        send_tts_messages=False),
                     orole: discord.PermissionOverwrite(read_messages=True,read_message_history=True,
                        send_messages=True) }

        # If the channel does not exist, create it
        if not channel:
            if orole:
                # Create the channel and set permissions
                channel = await guild.create_text_channel('companion-administration', \
                    overwrites=overwrites, position=len(guild.channels), \
                    topic='This channel is for Companion administration.')
            else:
                # Owner role does not exist, should never happen.
                return None
        else:
            # Force channel to proper security settings
            channel.edit(overwrites=overwrites)
        return channel
    except Exception as err:
        ErrorLog(f'VCA: {sys.exc_info()[-1].tb_lineno}/{err}')

# Perform security audit on a given guild

async def SecurityAudit(guild=None,message=None,ShowResults=False,auto=False):
    # failsafe catch
    if guild==None and message==None:
        return

    # Make sure we have a guild structure
    if not guild and message:
        guild=message.guild

    # Create the CompanionAdministration area (if not exist) and get the channel
    admin=await VerifyCompanionAdministration(guild)

    # Start with the automatic setting. Results will be forced if audit fails
    FailedAudit=False
    AuditOwnerRole=False
    IsHighestPos=False
    IsOwnerInRole=False
    GuildVerification=False
    ExplicitContent=False
    MFAlevel=False
    IsEveryoneMention=False

    orole=discord.utils.get(guild.roles,name='owner')
    if orole:
        AuditOwnerRole=True
        hrp=max(role.position for role in guild.roles)  # Get the highest role position
        if orole.position==hrp:
            IsHighestPos=True
        else:
            FailedAudit=True

        urole=discord.utils.get(guild.owner.roles,name='owner')
        if urole:
            IsOwnerInRole=True
        else:
            FailedAudit=True
    else:
        FailedAudit=True

    if str(guild.verification_level.name)=='highest':
        GuildVerification=True
    else:
        FailedAudit=True

    if str(guild.explicit_content_filter)=='all_members':
        ExplicitContent=True
    else:
        FailedAudit=True

    if str(guild.mfa_level)=='MFALevel.require_2fa':
        MFAlevel=True
    else:
        FailedAudit=True

    # Check permissions for @everyone role
    if not guild.default_role.permissions.mention_everyone:
        IsEveryoneMention=True
    else:
        FailedAudit=True

    # Report the results
    if ShowResults or FailedAudit:
        await admin.send(f"Guild: {guild.name} ({guild.id})")
        await admin.send(f"Owner: {guild.owner} ({guild.owner.id})")
        if not AuditOwnerRole:
            await admin.send(f"The `owner` role does not exist. A dedicated guild owner role is vital for securing control, ensuring only trusted hands hold top permissions. This role acts as the ultimate safeguard against unauthorized changes, breaches, and ensures accountability in managing server integrity.")
        if not IsHighestPos:
            await admin.send(f"The `owner` role does NOT have the highet position in the role list. Please visit the [Discord Role Management](https://support.discord.com/hc/en-us/articles/214836687-Role-Management-101) for more details.")
        if not IsOwnerInRole:
            await admin.send(f"{guild.owner} is NOT in the `owner` role.")
        if not GuildVerification:
            await admin.send(f"this guild is NOT protected with the highest verification level.  Please visit the [Discord Verification Levels](https://support.discord.com/hc/en-us/articles/216679607-Verification-Levels) for more details.")
        if not ExplicitContent:
            await admin.send(f"Sensitive content filter is NOT set to the hight level. Please visit the [Sensitive Content Filter](https://support.discord.com/hc/en-us/articles/18210995019671-Discord-Sensitive-Content-Filters) for more details.")
        if not MFAlevel:
            await admin.send(f"This guild is NOT protected by two factor authentication. Please visit the [Discord Multifactor Authentication](https://support.discord.com/hc/en-us/articles/219576828-Setting-up-Multi-Factor-Authentication) for more details.")
        if not IsEveryoneMention:
            await admin.send(f"Allowing the `@everyone` role to ping everyone opens the door to spam and raid abuse, as any member could trigger mass notifications, disrupting user experience and overwhelming the server. This permission should always be restricted to prevent chaos and maintain a controlled, respectful communication environment. Please visit [Discord Role Management](https://support.discord.com/hc/en-us/articles/214836687-Role-Management-101) for more details.")

        if ShowResults:
            await admin.send(f"Current Members: {guild.member_count}")
        if FailedAudit:
            await admin.send(f"**This server has FAILED the security audit.** Please correct the above issues as quickly as possible.")
            if auto:
                await admin.send(f"This audit was performed as a part of Companion's automated maintenance. You will continue to receive these messages as long as the above issues remain uncorrected.")
            await admin.send(f"Thank you.")
        else:
            if ShowResults:
                await admin.send(f"**This server has PASSED the security audit.**")

# Check for owner impersonations.

async def ImposterAmoungUs(guild,member):
    try:
        # Retrieve the guild and owner information
        guild = guild
        owner = guild.owner
        owner_name = owner.name.lower()
        owner_nick = owner.display_name.lower()
        member_name = member.name.lower()
        member_nick = member.display_name.lower()

        # Check if the new member has the same username or display name as the owner
        if member != owner and (member_name == owner_name or member_nick == owner_nick):
            # Fetch URLs for avatars
            member_avatar_url = member.display_avatar.url
            owner_avatar_url = owner.display_avatar.url

            # Load images for comparison
            try:
                member_avatar_image = LoadImageURL(member_avatar_url)
                owner_avatar_image = LoadImageURL(owner_avatar_url)
            except Exception as err:
                ErrorLog(f"IAU Broken: Avatar load/{err}")
                return False

            # Convert avatars to perceptual hashes
            member_hash = imagehash.phash(member_avatar_image)
            owner_hash = imagehash.phash(owner_avatar_image)

            # Compare hash distance (simple comparison)
            if member_hash == owner_hash:
                # Ban the member for impersonation
                await member.ban(reason="Impersonating the server owner")
                await ModeratorNotify(bot,member.guild,f"{member}/{member.id} banned for impersonating owner.")
                return True
    except Exception as err:
        ErrorLog(f'IAU: {sys.exc_info()[-1].tb_lineno}/{err}')
    return False

# Check for input for personal identifying information (PII). Even Companion
# will get caught in these validations. This may be a bad idea, but Bots seem to
# have a wicked high number of false positives. Once an AI classifier is in
# place, this may not be needed.

async def IsPIIDetected(bot,message):
    if bot['PIIModeration'].lower()!='no' and os.path.exists(bot['PII'])==True:
        # Check whitelist
        piiList=bot['PIIWhitelist'].split(',')
        for uc in piiList:
            # Is this a whitelisted user
            if uc[0]=='@':
                if uc[1:].lower()==message.author.name.lower():
                    return False
            # Is this a white listed channel
            if uc[0]=='#':
                if uc[1:].lower()==message.channel.name.lower():
                    return False

        HasPII=await DetectPII(message.content)
        if HasPII:
            await ModeratorNotify(bot,message.guild,f"PII detected: {message.author.name}/{message.author.id} in {message.channel.name}, {HasPII}")
            await ModeratorNotify(bot,message.guild,f"{message.content}")
            author=str(message.author.mention)
            # If its a bot, it doesn't deserve a response
            if not message.author.bot:
                await send_response(bot,message,PickRandomResponse(bot['PII']),delete=300)
            await message.delete()
            return True

    return False

###
### Background Tasks
###

# Run automated security audit

@tasks.loop(hours=23)
async def AutomatedSecurityAudit():
    for guild in client.guilds:
        await SecurityAudit(guild,None,False,True)
        await asyncio.sleep(0)

# This task sweeps all memry fils in a given server and purges any memory
# file over X days. Housekeeping is required otherwise users will burn
# storage and there MUST be reasonable limits. Rune ONCE a day.

@tasks.loop(hours=23)
async def MemoryMaintenance():
    # Get server CFg files
    cfg_files=[os.path.join(ConfigStorage, file) for file in os.listdir(ConfigStorage) if file.endswith('.cfg')]

    # Read server CFG file and get MaxMemory
    for cfg in cfg_files:
        try:
            Config=json.loads(jsonFilter(ReadFile(cfg)))
            await asyncio.sleep(0)
        except Exception as err:
            ErrorLog(f"{cfg} damaged: {sys.exc_info()[-1].tb_lineno}/{err}")
            continue

        # Get how long to keep old memory files in seconds
        MaxMemory=float(Config['MaxMemory'])*86400
        sid=cfg.split('/')[5].split('.')[0]
        dn=f"{MemoryStorage}/{sid}"

        # Get list of .memory files for this server

        mfiles=[]
        for dirpath, _, filenames in os.walk(dn):
            for file in filenames:
                if file.endswith('.memory'):
                    mfiles.append(os.path.join(dirpath, file))

        # Now check the memory files for age. If the file is OLDER then
        # MaxMemory, delete it.

        ct=time.time()
        for mf in mfiles:
            lmt=os.path.getmtime(mf)
            if ct-lmt>MaxMemory:
                os.remove(mf)
            await asyncio.sleep(0)

# Handle autodelete messages. It is important to consider that when this
# is executed, the original message may not exist. We have to fetch
# message from the guild, channel, and message IDs.

@tasks.loop(seconds=3)
async def autodelete_messages():
    global delete_list

    if DeleteLock.acquire(timeout=DeleteTimeout):
        try:
            now=time.time()
            if delete_list:
                for msg in list(delete_list):
                    if now>msg['Expires']:
                        guild=client.get_guild(msg['gid'])              # Guild
                        channel=guild.get_channel(msg['cid'])           # Channel
                        message=await channel.fetch_message(msg['mid']) # Message

                        delete_list.remove(msg)
                        await message.delete()
        except Exception as err:
            ErrorLog(f'Broke ADM: {sys.exc_info()[-1].tb_lineno}/{err}')
        DeleteLock.release()
    else:
        ErrorLog("Lock failed ADM")

# Handle the circular queue for the guilds.

def RotateGuildQueue():
    global GuildQueueLock
    global GuildQueue

    # Add the guild to the circular guild queue
    if GuildQueueLock.acquire(timeout=GuildQueueTimeout):
        top=GuildQueue.pop(0)
        GuildQueue.append(top)
        GuildQueueLock.release()

    return top

# The dirty part. I wanted to serialize requests for the bot, so a timer
# approach is used coupled with a locking method. This keep a rate limit
# approach for the open AI api in accordance to its policies. Sleeping
# method can also be added.

# The downside to a completely serializd approach is that handling large
# multiple guilds can monopolize resources. To address this issue, I am
# using a circular queue where requests in a single server are
# serialized, but multiple servers can run concurrently.

@tasks.loop(seconds=3)
async def update_response_data():
    global BabbleLock
    global ResponseLock
    global GuildQueueLock
    global GuildQueue

    try:
        guild=RotateGuildQueue()

        # Check to see is the guild is available to babble
        if guild.id in BabbleLock and BabbleLock[guild.id].locked():
            return

        # Pull the next request

        request=None
        if ResponseLock.acquire(timeout=ResponseTimeout):
            request=GetNextRequest(guild.id)
            ResponseLock.release()

        # Only 1 AI request at a time

        if request!=None:
            # Create guild lock for babbling
            if guild.id not in BabbleLock:
                BabbleLock[guild.id]=threading.Lock()

            if BabbleLock[guild.id].acquire(timeout=BabbleTimeout):
                try:
                    await HandleOneMessage(request)
                except Exception as err:
                    # It broke, try to put the request back in the queue
                    if ResponseLock.acquire(timeout=ResponseTimeout):
                        PutNextRequest(guild.id,request)
                        ResponseLock.release()
                    ErrorLog(f"Broke: {sys.exc_info()[-1].tb_lineno}/{str(err)}")
                BabbleLock[guild.id].release()
            else:
                # Couldn't get the lock, try to put the request back in the queue
                if ResponseLock.acquire(timeout=ResponseTimeout):
                    PutNextRequest(guild.id,request)
                    ResponseLock.release()
    except Exception as err:
        ErrorLog(f'Broke URD: {sys.exc_info()[-1].tb_lineno}/{err}')

# This function cleans up the active user lists.

# The reduce factor weighs in on the user typing within the channel. It
# acts as a cool down to prevent a channel raid. and keep the slowmode
# appripriate to the channel "pressure".

@tasks.loop(seconds=60)
async def track_active_users():
    global active_users
    global active_joins

    try:
        current_time=time.time()
        # Sweep every channel
        for ac in list(active_users):
            # Sweep users in a channel
            for au in list(active_users[ac]):
                # Check time added againt expiration
                if (current_time-au[1])>SLOW_MODE_COOLDOWN:
                    # reduce factor
                    au[2]-=1
                    if au[2]<1:
                        active_users[ac].remove(au)
                    else:
                        au[1]=time.time()

        # Sweep all guilds
        for ag in list(active_joins):
            # Sweep all users in join list
            for au in list(active_joins[ag]):
                if (current_time-au[1])>SLOW_MODE_COOLDOWN:
                    active_joins[ag].remove(au)

    except Exception as err:
        ErrorLog(f'TAU Broke: {sys.exc_info()[-1].tb_lineno}/{err}')

###
### Discord event functions
###

# This section deals with a particularly visicous attack where the
# attacker asks an innocent question like "how many sides to an octogon?"

# The victim will respond 8.

# The attacker then edits the question to read "How old are you?" or
# "what is your age?" and takes a screen shot. The attacker then uses the
# screen shot to get the victim permenantly banned, as it looks like the
# victim violated Discord's age restrictions. The is a zero tolorence
# policy for Discord and a viscious way to target people.

# There is one serious restriction to this. Is a message is posted prior
# to the bot being loaded, but edited after the fact, the bot won't
# receive the edit notification. THIS IS A MAJOR LOOPHOLE, but one only
# DISCORD can fix.

# It seems one of the best ways to defeat this is just to delete the
# original message.

@client.event
async def on_message_edit(before, after):
    # Search for word in list
    def CheckWordList(side,sampleText):
        Found=False
        for w in range(len(side)):
            if side[w] in sampleText:
                Found=True
                break
        return Found

    try:
        if after.content==before.content:
            return

        # If this is a thread, get the parent channel
        pchannel=after.channel
        nsfw=None
        if isinstance(after.channel,discord.Thread):
            pchannel=after.channel.parent
            nsfw=after.channel.parent.nsfw
        else:
            nsfw=after.channel.nsfw

        channel=str(pchannel)
        uid=str(after.author.id)
        bot=GetCompanionPersona(after.guild.id,channel,nsfw)
        if bot==None:
            return

        # Log everything
        if bot['AutoLogging'].lower()!='no':
            DisectMessage("Message edited (before)",before)
            DisectMessage("Message edited (after)",after)

        # Manage automated moderation
        if bot['AutoModeration'].lower()=='no':
            return

        # Build leet lists

        leftside=BuildLeetList(lside)
        rightside=BuildLeetList(rside)

        sampleText=StripPunctuation(after.content.lower())

        leftFound=CheckWordList(leftside,sampleText)
        rightFound=CheckWordList(rightside,sampleText)

        # NEED a global moderation switch
        # Check for vulgarity in the edited response

        # This could be a problem at the global level of a server, where
        # partial moderation may be desired, vs an absolute approach.

        if bot['AutoModeration'].lower()!='no' \
        and os.path.exists(bot['Vulgarity']) \
        and bot['AllowVulgarity'].lower()!='yes' \
        and not nsfw:
            if bool(pc.predict([ after.content ]))==True:
                await ModeratorNotify(bot,after.guild,f"{after.author.name}/{after.author.id} chastized for vulgarity in {after.channel.name}")
                await send_response(bot,after,PickRandomResponse(bot['Vulgarity']),delete=57)
                try: # delete the offending message
                    await after.delete()
                except:
                    pass
                return

        if leftFound and rightFound:
            await ModeratorNotify(bot,after.guild,f"LEET words/Malicious edit possibility: {after.author.name}/{after.author.id} in {after.channel.name}")
            # This seems to be a better way to ruin the attacker's plan
            embed=discord.Embed(
                title='Message edited',
                description=f'UID: {uid}\nAuthor: {after.author}\n\nBefore edit:\n\n{before.content}\n\nAfter edit:\n\n{after.content}\n\n',
                color=discord.Color.red() )
#            try: # delete the edited message
#                await after.delete()
#            except:
#                pass
            await send_response(bot,after,None,embed=embed)
            return

    except Exception as err:
        ErrorLog(f'Broken Edit: {sys.exc_info()[-1].tb_lineno}/{err}')

# Log deleted messages. Nothing escapes the watchful eye of the moderation
# system

@client.event
async def on_message_delete(message):
    # Figure out which persona is calling the shots.
    channel=str(message.channel)
    uid=str(message.author.id)
    bot=GetCompanionPersona(message.guild.id,channel,message,channel.nsfw)
    if bot==None:
        return

    # Log everything
    if bot['AutoLogging'].lower()!='no':
        DisectMessage("Deleted message",message)

# Make a nice announcement welcoming the user to the server.  Use the
# 'Welcome' bot to provide a nice welcoming message.

@client.event
async def on_member_join(member):
    global active_joins

    try:
        # Track new member joins
        key=member.guild.id
        if key not in active_joins:
            active_joins[key]=[]
        if member.id not in active_joins[key]:
            ut=[member.id,time.time()]
            active_joins[key].append(ut)

        # Welcome forces the default bot.
        bot=GetCompanionPersona(member.guild.id,None,Welcome=True)
        if bot==None:
            return

        if bot['AutoLogging'].lower()!='no':
            ErrorLog(f"OMJ: {member}")

        # If there is a moderator area, send a message to it.
        await ModeratorNotify(bot,member.guild,f"{member}/{member.id} joined.")

        if ImposterAmoungUs(member.guild,member):
            return

        if os.path.exists(bot['Welcome']):
            # Figure out which persona is calling the shots.
            response=PickRandomResponse(bot['Welcome']).replace('{username}',f'**{member.mention}**')
            # A message of None will automatically refer to the system channel
            await send_response(bot,None,response,member=member)
    except Exception as err:
        ErrorLog(f'OMJ: Error sending message: {sys.exc_info()[-1].tb_lineno}/{err}')

# Record the user leaving the server in the designated moderator area.

@client.event
async def on_member_remove(member):
    try:
        # Welcome forces the default bot.
        bot=GetCompanionPersona(member.guild.id,None,Welcome=True)
        if bot==None:
            return

        if bot['AutoLogging'].lower()!='no':
            ErrorLog(f"OMR: {member}")

        # If there is a moderator area, send a message to it.
        await ModeratorNotify(bot,member.guild,f"{member}/{member.id} left.")
    except Exception as err:
        ErrorLog(f'OMR: Error sending message: {sys.exc_info()[-1].tb_lineno}/{err}')

# Implement an auto slowmode based on actual users typing per channel
# NOT bot dependant... RETHINK this for CFG settings and enable/disable.

@client.event
async def on_typing(channel, user, when):
    global active_users
    global active_joins

    try:
        # if direct message, ignore
        if isinstance(channel,discord.DMChannel):
            return

        # If this is a thread, get the parent channel
        pchannel=channel
        if isinstance(channel,discord.Thread):
            pchannel=channel.parent

        # Track active member joins
        joins=1
        if pchannel.guild.id in active_joins:
            joins=len(active_joins[channel.guild.id])

        # joins will be used a a multiplier so is the threshold is not met, then
        # a multiplier of 1 is used is keep the method simple.

        if joins<=int(len(pchannel.guild.members)*0.01):
            joins=1

        # Create a unique key for the channel using guild and channel IDs
        key = f"{pchannel.guild.id}.{pchannel.id}"

        # When this function gets called, someone was typing. Add them to
        # the channel tracking list.

        if key not in active_users:
            active_users[key]=[]

        found=False
        for u in active_users[key]:
            if u[0]==user.id:
                # Reset the timer
                u[1]=time.time()
                u[2]+=1*joins
                found=True

        if not found:
            # User ID, and the time they were typing, factor
            # The factor is used as a decrementer to prevent manipulation
            ut=[user.id,time.time(),joins]
            active_users[key].append(ut)

        # Calculate the number of typing users in the channel
        typing_count=len(active_users[key])

        # Check if the cooldown has expired. Slowdown can only be adjust
        # ONCE every 5 minutes per channel.

        current_time = time.time()
        last_change = last_slow_mode_change.get(key, 0)
        if current_time - last_change < SLOW_MODE_COOLDOWN:
            return  # Skip the adjustment process if still in cooldown

        # Calculate expected users
        server = channel.guild

        # Theory: 1% of all active users throughout the server should be
        # active normally. Assuming the distribution of users will be
        # spread out over the number of channels, gives us an expected
        # number of users per channel. This is a fallacy, but it is a
        # reasonable starting point to build the theory on. Possible
        # expansions could be actually messuring user activity per
        # channel, but to get something very basic, I felt this was
        # reasonable enough for most applications given that I am using
        # only 3 secords per user as the slowdown rate, unless the number
        # of user is above the expected amount. This is a primitive
        # anti-raid method.

        expected_users = int(max(1, round(len(server.members) * 0.01 / len(server.channels))))
        if expected_users<1:
            expected_users=1

        # Determine slow mode duration
        if typing_count > 2 * expected_users:  # Over threshold
            bot=GetCompanionPersona(server.id,None,Welcome=True)
            await ModeratorNotify(bot,server.id,f"Under potential raid attack, {joins} joins, {typing_count} users > {expected_users} users")
            slow_mode_duration = SLOW_MODE_DURATION * typing_count*10*joins
        elif typing_count > expected_users:
            slow_mode_duration = SLOW_MODE_DURATION * typing_count*joins
        else:
            slow_mode_duration = 0

        # Apply slow mode
        await pchannel.edit(slowmode=slow_mode_duration)
        last_slow_mode_change[key] = current_time  # Update the last change time
        print(f"Slowmode {server.id}/{channel.name}: {slow_mode_duration} seconds, {typing_count} active, {expected_users} expected")
    except Exception as err:
        ErrorLog(f'OnType Broke: {sys.exc_info()[-1].tb_lineno}/{err}')

# Get the user message and add it to a processing list. This really is the
# driving point of the AI responses. Currently it responds to any message
# in the designated areas, but it could easily be adapted to respond to
# message of a particular interest, like cooking, or programming.

@client.event
async def on_message(message):
    global ResponseLock
    global GuildQueueLock
    global GuildQueue
    global active_joins

    try:
        key=message.guild.id
        if key not in active_joins:
            active_joins[key]=[]
        if message.author.id not in active_joins[key]:
            ut=[message.author.id,time.time()]
            active_joins[key].append(ut)

        # Ignore messages from the bot itself. This does NOT work with webhooks,
        # so We need to check for that too.

        if message.author==client.user:
            return

        # Handle direct messages
        if isinstance(message.channel,discord.DMChannel):
            await message.channel.send(f'You have messaged the Companion AI chatbot/moderation. This bot functions ONLY within the limits of a Discord server and does NOT support interactions via DMs. Thank you.')
            return

        # Figure out which persona is calling the shots.
        guild=message.guild
        # Add the guild to the circular guild queue, if not already in it.
        if guild.id not in GuildQueue and GuildQueueLock.acquire(timeout=GuildQueueTimeout):
            GuildQueue.append(guild)
            GuildQueueLock.release()

        channel=str(message.channel)
        uid=str(message.author.id)

        # Owner role information. This will be used to verify bot commands.
        orole=discord.utils.get(guild.roles,name='owner')
        # Bots/webhooks will breaks this... safe way to make sure webhook can
        # never be registered as owner
        if not message.author.bot:
            mrole=orole and orole in message.author.roles
        else:
            mrole=None

        # Handle auto publish
        if message.channel.type==discord.ChannelType.news:
            await message.publish()

        # NSFW not allowed in threads, so find parent channel
        bot=None
        nsfw=False
        if isinstance(message.channel,discord.Thread):
            pchannel=str(message.channel.parent)
            nsfw=message.channel.parent.nsfw
            bot=GetCompanionPersona(message.guild.id,pchannel,nsfw)
            # WTAF? Really? bots have to join a thread...
            if not message.channel.me:
                await message.channel.join()
        else:
            nsfw=message.channel.nsfw
            bot=GetCompanionPersona(message.guild.id,channel,nsfw)
        if bot==None:
            return

        # Log everything
        if bot['AutoLogging'].lower()!='no':
            DisectMessage("Received message",message)

        # Now that we have a bot name, we can check for webhooks and make sure
        # they are not my own.

        if message.webhook_id and message.author.name==bot['BotName']:
            return

        # MUST BE FIRST!
        # Imposter among us no more!

        if await ImposterAmoungUs(message.guild,message.author):
            return

        # Check for input that is a number only
        if bot['AutoModeration'].lower()!='no' and os.path.exists(bot['AgeExploit'])==True and NumberOnly(message.content):
            await ModeratorNotify(bot,message.guild,f"AgeExploit detected: {message.author.name}/{message.author.id} in {message.channel.name}")
            author=str(message.author.mention)
            # If its a bot, it doesn't deserve a response
            if not message.author.bot:
                await send_response(bot,message,PickRandomResponse(bot['AgeExploit']),delete=300)
            await message.delete()
            return

        # Check if message has any PII
        if await IsPIIDetected(bot,message):
            return

        # This is really the only absolute exception to BOT responsing...
        # Check for scam links and delete them.

        # BUILD FALSE POSITIVES LIST, so far I haven't ran into any

        if os.path.exists(CompanionScamURLS)==True and os.path.exists(bot['ScamURLS'])==True and '://' in message.content:
            scamurls=ReadFile2List(CompanionScamURLS)
            for url in scamurls:
                if url in message.content:
                    print(f"ScamURL: {url} {message.author.mention}")
                    author=str(message.author.mention)
                    # If its a bot, it doesn't deserve a response
                    if not message.author.bot:
                        await send_response(bot,message,PickRandomResponse(bot['ScamURLS']),delete=57)
                    await message.delete()
                    return

        if os.path.exists(CompanionAutoFilter)==True and os.path.exists(bot['AutoFilter'])==True:
            autofilter=ReadFile2List(CompanionAutoFilter)
            for text in autofilter:
                if text in message.content:
                    author=str(message.author.mention)
                    # If its a bot, it doesn't deserve a response
                    if not message.author.bot:
                        await send_response(bot,message,PickRandomResponse(bot['AutoFilter']),delete=57)
                    await message.delete()
                    return

        # Don't respond to other bots.
        if message.author.bot and bot['AllowBot'].lower()!='yes':
            return

        # Allow the user to erase their own stored conversation

        if str(message.content).strip().startswith('%Forget'):
            await message.delete()
            dn=f"{MemoryStorage}/{guild.id}/{bot['BotName']}"
            mkdir(dn)
            fn=f"{dn}/{bot['BotName']}.{uid}.{channel}.memory"
            if os.path.exists(fn):
                os.remove(fn)
                await send_response(bot,message,"Conversation forgotten",delete=57)
            return

        # Only guild owner/Owner role allowed to use advanced commands
        if mrole:
            if str(message.content).strip().startswith('%SecurityAudit'):
                await message.delete()
                await SecurityAudit(guild,message,True)
                return

            if str(message.content).strip().startswith('%CheckBot'):
                member=message.guild.get_member(client.user.id) # Get the bot's member object in the guild
                # Check if the bot is a member of the channel
                if member in message.channel.members and bot['ResponseAllowed'].lower()=='yes':
                    await send_response(bot,message,"Allowed",delete=57)
                else:
                    await send_response(bot,message,"Not Allowed",delete=57)
                await message.delete()
                return

            if str(message.content).strip().startswith('%PurgeRequests'):
                # Give the AI the message
                if ResponseLock.acquire(timeout=ResponseTimeout):
                    rname=f"{MemoryStorage}/{gid}/requests.txt"
                    if os.path.exists(rname):
                        os.remove(rname)
                        msg=f"Rrequests purged"
                    else:
                        msg=f"Request list already empty"
                    ResponseLock.release()
                    await send_response(bot,message,msg,delete=57)
                else:
                    ErrorLog("PurgeRequest Lock failed")
                return

        # If we have a bot, then we can converse here.

        # Check to see if the message is a replay to the bot, or a mention or a
        # public message, specifically that the user used the reply feature of the
        # APP, or the @ and bot name, if talking to the bot. This convoluted
        # approach is needed because all bot replies are via webhooks. Webhooks
        # have different user IDs then the bot.

        # All of this is NECCESSARY if we want the ability to server multiple
        # personas, each with its own avatar. Discord does NOT allow multiple
        # avatars per a single user (bot.user) without changing EVERY avatar in
        # EVERY channel. Using webhooks is the only viable option to acheive
        # multiple AI personas in an imersive methodology.

        botReference=False
        if message.reference is not None and message.reference.message_id is not None:
            refmsg=await message.channel.fetch_message(message.reference.message_id)
            # ID won't work here because everything is sent via webhook
            if (refmsg.author.name==client.user.name or refmsg.author.name==bot['BotName']):
                botReference=True

        publicMsg=message.reference==None and len(message.mentions)==0 and len(message.role_mentions)==0 and len(message.channel_mentions)==0
        botAnswer=(publicMsg or botReference or client.user in message.mentions)

        # Verify that the bot is no talking to itself. Webhooks rotate
        # constantly and when bot injection is used, is is very possible
        # to create a loop. These checks make sure that doesn't happen.

        if bot['ResponseAllowed'].lower()=='yes' and bot['Channel']!=None and botAnswer and message.author.name.split('#')[0]!=bot['BotName']:
            input_text=message.content.strip()

            # If a trigger file exists, check to see if one on the trigger words are in the user message.
            # Also if trigger file exists, and message is directed to bot.
            trigger=f"{CompanionStorage}/{bot['BotName']}/{bot['BotName']}.{channel}.trigger"
            if os.path.exists(trigger):
                # If message is directed to bot, override trigger
                if client.user in message.mentions or (message.reference and message.reference.resolved.author.id==client.user.id):
                    pass
                else:
                    wfound=False
                    twords=ReadFile2List(trigger,ForceLower=True)
                    inwords=StripPunctuation(input_text.replace('  ',' ')).split(' ')
                    while '' in inwords:
                        inwords.remove('')
                    # Search the list word by word
                    for w in inwords:
                        if w.lower() in twords:
                            wfound=True
                            break
                    # A trigger word was not found, don't continue.
                    if wfound==False:
                        return

            # Anagram solver... how the hell did I end up don the rabbit hole? Really?

            if os.path.exists(AnagramWordList) and input_text.lower().strip().startswith('%anagramsolver'):
                letters=input_text[14:].strip().lower()
                input_text=AnagramSolver(letters)
                await send_response(bot,message,input_text)
                return

            # Read tags from YouTune video
            if os.path.exists(bot['YTtags']) and os.path.exists(bot['noYTtags']) \
            and input_text.lower().strip().startswith('%yttags'):
                # Web/URL reference
                url=input_text[7:].strip()
                input_text=yttags2text(url)
                if input_text==None:
                    await send_response(bot,message,PickRandomResponse(bot['noYTtags']))
                elif input_text=='{[(*VNF*)]}':
                    await send_response(bot,message,PickRandomResponse(bot['URLBroken']))
                else:
                    await send_response(bot,message,f"{PickRandomResponse(bot['YTtags'])}\n\n{input_text}")
                return

            # if the input text starts with "%http", replace it with the actual URL text
            if os.path.exists(bot['TooMuchInformation']) and input_text.lower().strip().startswith('%http'):
                # Web/URL reference
                url=input_text.replace(' ','')[1:]
                input_text=html2text(url)
                if input_text==None:
                    await send_response(bot,message,PickRandomResponse(bot['URLBroken']))
                    return

            # Give the AI the message
            if ResponseLock.acquire(timeout=ResponseTimeout):
                msg={}
                msg['input']=input_text
                msg['gid']=guild.id
                msg['cid']=message.channel.id
                msg['mid']=message.id
                PutNextRequest(guild.id,msg)
                ResponseLock.release()
            else:
                ErrorLog("Message Lost: Lock failed OM")
    except discord.HTTPException as err:
        if err.code==429:  # Rate limit error
            retry_after=int(err.response.headers.get('X-RateLimit-Reset', 1))*2
            print(f"Rate limit hit. Retrying after {retry_after} seconds.")
            await asyncio.sleep(retry_after)
            await on_message(message)  # Retry the request
    except Exception as err:
        ErrorLog(f"OM: {sys.exc_info()[-1].tb_lineno}/{str(err)}")

# When Companion joins a new guild

@client.event
async def on_guild_join(guild):
    global GuildQueueLock
    global GuildQueue

    try:
        ErrorLog(f"Companion invited to new guild: {guild}/{guild.id}")
        # Add the guild to the circular guild queue
        if guild.id not in GuildQueue and GuildQueueLock.acquire(timeout=GuildQueueTimeout):
            GuildQueue.append(guild)
            GuildQueueLock.release()

        mkdir(f'{MemoryStorage}/{guild.id}')
        mkdir(f'{LoggingStorage}/{guild.id}')
        await SecurityAudit(guild,None,False,True)
    except Exception as err:
        ErrorLog(f"OGJ: {sys.exc_info()[-1].tb_lineno}/{str(err)}")

# When Companion is removed from a guild.
# TODO: purge all guild files.

@client.event
async def on_guild_remove(guild):
    global GuildQueueLock
    global GuildQueue

    try:
        ErrorLog(f"Companion kicked out of guild: {guild}/{guild.id}")
        # Add the guild to the circular guild queue
        if guild.id in GuildQueue and GuildQueueLock.acquire(timeout=GuildQueueTimeout):
            GuildQueue.remove(guild)
            GuildQueueLock.release()
    except Exception as err:
        ErrorLog(f"OGR: {sys.exc_info()[-1].tb_lineno}/{str(err)}")

# Start the timer task for responses.

@client.event
async def on_ready():
    print(f'Logged in as {client.user}')

    try:
        # Print some fluff
        for guild in client.guilds:
            # Add the guild to the circular guild queue, if not already in it.
            if guild.id not in GuildQueue and GuildQueueLock.acquire(timeout=GuildQueueTimeout):
                GuildQueue.append(guild)
                GuildQueueLock.release()

            # Make sure the neccessary directories exist
            mkdir(f'{MemoryStorage}/{guild.id}')
            mkdir(f'{LoggingStorage}/{guild.id}')

            # Check if the bot's role has administrator permissions
            if not guild.me.guild_permissions.administrator:
                print(f"  Error: Companion does not have administrator privileges in {guild.name}.")

        # Start the task when the bot is ready
        update_response_data.start()
        autodelete_messages.start()
        track_active_users.start()
        MemoryMaintenance.start()
        AutomatedSecurityAudit.start()

        print("Ready to serve!")
    except Exception as err:
        print(f"ERR: {err}")

###
### STARTUP: starts the bot with the corresponding token
###

if __name__=='__main__':
    try:
        print(f'Companion {Version}')
        mkdir(ConfigStorage)

        Tokens=ReadTokens()

        client.run(Tokens['Discord'],log_handler=None)
    except Exception as err:
        ErrorLog(f"Broken MAIN: {err}")

### END OF PROGRAM



